;-----------------------------------------------------------------------
; Sigma16 program BarChart
; Computer Systems 1 Assessed Exercise
; Stuart Reilly, 2258082, TU15, 09/03/17
; CS1Q

;-----------------------------------------------------------------------
; Status report

; This is a finished solutions, which assembles without error and produces
; correct results.

;-----------------------------------------------------------------------

; This program prints a bar chart showing the values in an array x
; containing a sequence of n integers.  There is also an integer limit
; that is used to limit the length of output lines.

; There is one line of output for each element of x, consisting of a
; row of asterisks (*).  Normally, the number of asterisks in line is
; x[i].  However, if x[i] is negative, then a minus sign is printed
; instead of asterisks.  Furthermore, the number of asterisks printed
; must never exceed limit.  If x[i] > limit then only limit asterisks
; are printed, and they are followed by a greater-than sign (>) which
; indicates that the output was truncated.

;-----------------------------------------------------------------------
; High level algorithm
; 
; for i := 0 to n-1
;    k := 0
;    if x[i] < 0
;       then outbuf[k] := '-'
;            k := k + 1
;       else
;          while k < x[i] && k < limit do
;              outbuf[k] := '*'
;              k := k + 1
;          if k < x[i]
;             then outbuf[k] := '>'
;                  k := k + 1
;    outbuf[k] := newline character
;    k := k+1
;    write outbuf with length = k

;-----------------------------------------------------------------------
; Intermediate level algorithm

; (This is the "goto form" of the program.  It's written in high level
;  language notation but limited to assignment statements, goto Label,
;  if condition then goto Label, write.)

;i := 0
;:top
;if (i > n-1) goto end
;    k := 0
;
;    if (x[i] >= 0) goto else     
;    outbuf[k] := -
;    k := k+1
;    goto print
;    :else
;        :while
;            if (k >= x[i] || k >= limit) goto arrow
;            outbuf[k] := '*'
;            k := k + 1
;            goto while
;        :arrow
;            if (k >= x[i]) then goto print
;            outbuf[k] := '>'
;            k := k + 1
;
;    :print
;    outbuf[k] := '\n'
;    k := k+1
;    print outbuf
;    i := i+1
;    goto top
;:end

;-----------------------------------------------------------------------
; Assembly language implementation
 
;-- Instructions go here, with proper comments

; Initalise registers with constants.
       lea       R1,1[R0]         ; R1 = 1
       lea       R2,2[R0]         ; R2 = 2
       load      R3,n[R0]         ; R3 = n
       load      R4,minus[R0]     ; R4 = -
       load      R5,gt[R0]        ; R5 = >
       load      R6,newline[R0]   ; R6 = /n
       load      R7,star[R0]      ; R7 = *
       load      R8,limit[R0]     ; R8 = limit
       lea       R9,outbuf[R0]    ; R9 = addr for outbuf
       lea       R10,0[R0]        ; R10 = 0                  (i = 0)
  
; If i is greater than n, exit, else, initalise k. If x[i] is negative
; append a '-' to outbuf and goto print. Otherwise, goto else.
top    cmp       R10,R3           ; R10 >= R3
       jumpge    end[R0]          ; Goto end if true
       lea       R11,0[R0]        ; R11 = 0                  (k = 0)
       load      R12,x[R10]       ; R12 = x[R10]             (R12 = x[i])
       cmp       R12,R0           ; R12 <= R0
       jumpge    else[R0]         ; Goto else if true
       store     R4,outbuf[R11]   ; outbuf[R10] = R4         (outbuf[k] = -)
       add       R11,R11,R1       ; R11 = R11 + R1           (k += 1)
       jump      print[R0]        ; Goto print
 
; If k is greater than x[i] or k is greater than limie, goto arrow. 
; Otherwise, append x[i] '*'s to outbuf.
else   cmp       R11,R12          ; R11 >= R12
       jumpge    arrow[R0]        ; Goto arrow if true
       cmp       R11,R8           ; R11 >= R8
       jumpge    arrow[R0]        ; Goto arrow if true
       store     R7,outbuf[R11]   ; outbuf[R10] = R7         (outbuf[k] = *)
       add       R11,R11,R1       ; R11 = R11 + R1           (k += 1)
       jump      else[R0]         ; Goto else

; if k is greater than limit, append '>' to outbuf
arrow  cmp       R11,R12          ; R11 < R12
       jumpge    print[R0]        ; Goto to print if true
       store     R5,outbuf[R11]   ; outbuf[R11] = R5         (outbuf[k] = >)
       add       R11,R11,R1       ; R11 = R11 + R1           (k += 1)

; Append a newline to outbuf and print outbuf to the console up to and including element k
print  store     R6,outbuf[R11]   ; outbuf[R11] = R6         (outbuf[k] = \n)
       add       R11,R11,R1       ; R11 = R11 + R1           (k += 1)
       trap      R2,R9,R11        ; Print outbuf
       add       R10,R10,R1       ; R10 = R10 + R1           (i += 1)
       jump      top[R0]          ; Goto top

end    trap      R0,R0,R0
;-----------------------------------------------------------------------
; Constants - initial values should not be changed

minus   data  $002d   ; code for '-'
gt      data  $003e   ; code for '>'
newline data  $000a   ; code for newline
star    data  $002a   ; code for '*'

;-----------------------------------------------------------------------
; Variables - these initial values may be changed

limit   data    10    ; maximum number of * to write

; x is the input: an array of n values to display in histogram
n       data    15    ; size of array x
x       data     1    ; x[0]
        data     2
        data     0
        data     3
        data    -2
        data     7
        data     8
        data     9
        data    10
        data    11
        data    12
        data    50
        data     3
        data     2
        data     1

;-----------------------------------------------------------------------
; Output buffer
outbuf  data  $0000   ; outbuf[0]
        data  $0000
        data  $0000
        data  $0000
        data  $0000
        data  $0000
        data  $0000
        data  $0000
        data  $0000
        data  $0000
        data  $0000
        data  $0000
        data  $0000
        data  $0000
        data  $0000
        data  $0000
        data  $0000
        data  $0000
        data  $0000
        data  $0000
        data  $0000
        data  $0000
        data  $0000
        data  $0000
        data  $0000
        data  $0000
